{"version":3,"sources":["webpack:///webpack/bootstrap 2cb95dc7bc056174aae3","webpack:///./webgl-library/Matrix.js","webpack:///./webgl-library/Context.js","webpack:///./webgl-library/Quaternion.js","webpack:///./webgl-library/Mesh.js","webpack:///./webgl-library/Program.js","webpack:///./webgl-library/Shader.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA,kDAA0C,oBAAoB,WAAW;;;;;;;;AC5IzE;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,eAAe;AAC1C,+BAA+B,oBAAoB;AACnD;AACA,mCAAmC,kBAAkB;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;;AAEA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC,2BAA2B,UAAU;AACrC;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+D;;;;;;;;;;ACjYA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,KAAK;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gE;;;;;;;;AC/GA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mE;;;;;;;;;;AC9HA;;AAEA;;AAEA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6D;;;;;;;ACrJA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE,KAAK;;AAE1E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oEAAoE,KAAK;;AAEzE;;AAEA;AACA;AACA;;AAEA,gE;;;;;;;AC3EA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+D","file":"commons.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [], result;\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);\n \t\twhile(resolves.length)\n \t\t\tresolves.shift()();\n \t\tif(executeModules) {\n \t\t\tfor(i=0; i < executeModules.length; i++) {\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = executeModules[i]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// objects to store loaded and loading chunks\n \tvar installedChunks = {\n \t\t2: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn Promise.resolve();\n\n \t\t// an Promise means \"currently loading\".\n \t\tif(installedChunks[chunkId]) {\n \t\t\treturn installedChunks[chunkId][2];\n \t\t}\n \t\t// start chunk loading\n \t\tvar head = document.getElementsByTagName('head')[0];\n \t\tvar script = document.createElement('script');\n \t\tscript.type = 'text/javascript';\n \t\tscript.charset = 'utf-8';\n \t\tscript.async = true;\n \t\tscript.timeout = 120000;\n\n \t\tif (__webpack_require__.nc) {\n \t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t}\n \t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".js\";\n \t\tvar timeout = setTimeout(onScriptComplete, 120000);\n \t\tscript.onerror = script.onload = onScriptComplete;\n \t\tfunction onScriptComplete() {\n \t\t\t// avoid mem leaks in IE.\n \t\t\tscript.onerror = script.onload = null;\n \t\t\tclearTimeout(timeout);\n \t\t\tvar chunk = installedChunks[chunkId];\n \t\t\tif(chunk !== 0) {\n \t\t\t\tif(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));\n \t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t}\n \t\t};\n\n \t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\tinstalledChunks[chunkId] = [resolve, reject];\n \t\t});\n \t\tinstalledChunks[chunkId][2] = promise;\n\n \t\thead.appendChild(script);\n \t\treturn promise;\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2cb95dc7bc056174aae3","'use strict';\r\n\r\nclass Matrix {\r\n    /**\r\n     *\r\n     * @param {number} rows\r\n     * @param {number} cols\r\n     */\r\n    constructor(rows, cols) {\r\n        this._rows = rows;\r\n        this._cols = cols;\r\n\r\n        this._data = new Array(rows * cols);\r\n        for (let i = 0; i < this._data.length; ++i)\r\n            this._data[i] = 0;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get rows() {\r\n        return this._rows;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get columns() {\r\n        return this._cols;\r\n    }\r\n\r\n    /**\r\n     * @param {number} row\r\n     * @param {number} col\r\n     * @param {number} value\r\n     */\r\n    setValue(row, col, value) {\r\n        if (value === undefined) {\r\n            value = col;\r\n            col = 0;\r\n        }\r\n\r\n        if (row < 0 || col < 0 || row >= this.rows || col >= this.columns)\r\n            throw new RangeError(\"invalid index\");\r\n\r\n        this._data[col + row * this.columns] = value;\r\n    }\r\n\r\n    /**\r\n     * @param row\r\n     * @param col\r\n     * @returns {number}\r\n     */\r\n    getValue(row, col) {\r\n        if (col === undefined)\r\n            col = 0;\r\n\r\n        if (row < 0 || col < 0 || row >= this.rows || col >= this.columns)\r\n            throw new RangeError(\"invalid index\");\r\n\r\n        return this._data[col + row * this.columns];\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix}\r\n     */\r\n    clone() {\r\n        let result = new Matrix(this.rows, this.columns);\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(i, j, this.getValue(i, j));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param matrix\r\n     * @returns {Matrix}\r\n     */\r\n    add(matrix) {\r\n        if (matrix.rows != this.rows || matrix.columns != this.columns)\r\n            throw new TypeError(\"invalid argument\");\r\n\r\n        let result = new Matrix(this.rows, this.columns);\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(i, j, this.getValue(i, j) + matrix.getValue(i, j));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param matrix\r\n     * @returns {Matrix}\r\n     */\r\n    sub(matrix) {\r\n        if (matrix.rows != this.rows || matrix.columns != this.columns)\r\n            throw new TypeError(\"invalid argument\");\r\n\r\n        let result = new Matrix(this.rows, this.columns);\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(i, j, this.getValue(i, j) - matrix.getValue(i, j));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param tensor\r\n     * @returns {Matrix}\r\n     */\r\n    mult(tensor) {\r\n        if (typeof tensor === 'number') {\r\n            let result = new Matrix(this.rows, this.columns);\r\n            for (let i = 0; i < this.rows; ++i)\r\n                for (let j = 0; j < this.columns; ++j)\r\n                    result.setValue(i, j, this.getValue(i, j) * tensor);\r\n            return result;\r\n        }\r\n        else if (tensor instanceof Matrix) {\r\n            if (this.columns != tensor.rows)\r\n                throw new RangeError(\"invalid size\");\r\n\r\n            let result = new Matrix(this.rows, tensor.columns);\r\n\r\n            for (let i = 0; i < this.rows; ++i)\r\n                for (let j = 0; j < tensor.columns; ++j) {\r\n                    let sum = 0;\r\n                    for (let k = 0; k < this.columns; ++k)\r\n                        sum = sum + this.getValue(i, k) * tensor.getValue(k, j);\r\n\r\n                    result.setValue(i, j, sum);\r\n                }\r\n\r\n            return result;\r\n        }\r\n        else\r\n            throw new TypeError(\"not implemented yet\");\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix}\r\n     */\r\n    transpose() {\r\n        let result = new Matrix(this.columns, this.rows);\r\n\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(j, i, this.getValue(i, j));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param {number} i\r\n     * @param {number} j\r\n     */\r\n    swapRows(i, j) {\r\n        if (i === j) return;\r\n        for (let column = 0; column < this.columns; ++column) {\r\n            let temp = this.getValue(i, column);\r\n            this.setValue(i, column, this.getValue(j, column));\r\n            this.setValue(j, column, temp);\r\n        }\r\n    }\r\n\r\n    _findNonZeroUnder(row, column) {\r\n        while (row < this.rows) {\r\n            if (this.getValue(row, column))\r\n                return row;\r\n            row++;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix}\r\n     */\r\n    inverse() {\r\n        if (this.rows != this.columns || this.rows < 1)\r\n            throw new TypeError(\"invalid matrix sizes\");\r\n\r\n        let result = Matrix.identity(this.rows);\r\n        let self = this.clone();\r\n\r\n        for (let i = 0; i < self.rows; ++i) {\r\n            let row = self._findNonZeroUnder(i, i);\r\n            if (row === null)\r\n                throw new Error(\"determinants equals zero\");\r\n\r\n            self.swapRows(i, row);\r\n            result.swapRows(i, row);\r\n\r\n            let diagonal = self.getValue(i, i);\r\n\r\n            for (let j = 0; j < self.columns; ++j) {\r\n                self.setValue(i, j, self.getValue(i, j) / diagonal);\r\n                result.setValue(i, j, result.getValue(i, j) / diagonal);\r\n            }\r\n\r\n            for (let k = 0; k < self.rows; ++k) {\r\n                if (k === i) continue;\r\n                let coefficient = self.getValue(k, i);\r\n                for (let j = 0; j < self.columns; ++j) {\r\n                    self.setValue(k, j, self.getValue(k, j) - self.getValue(i, j) * coefficient);\r\n                    result.setValue(k, j, result.getValue(k, j) - result.getValue(i, j) * coefficient);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * only for vectors\r\n     * @param tensor\r\n     * @returns {number}\r\n     */\r\n    dot(tensor) {\r\n        let valid = Matrix.isVector(this) && Matrix.isVector(tensor) && this.rows === tensor.rows;\r\n        if (!valid)\r\n            throw TypeError('invalid tensor types');\r\n        let sum = 0;\r\n        for (let i = 0; i < this.rows; ++i)\r\n            sum = sum + this.getValue(i, 0) * tensor.getValue(i, 0);\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * only for vectors\r\n     * @param {Matrix} tensor\r\n     * @returns {Matrix}\r\n     */\r\n    cross(tensor) {\r\n        let valid = Matrix.isVector(this, 3) && Matrix.isVector(tensor, 3);\r\n\r\n        if (!valid)\r\n            throw TypeError('invalid tensor types');\r\n\r\n        let skewSymmetric = Matrix.fromRows([\r\n            [0, -this.getValue(2), this.getValue(1)],\r\n            [this.getValue(2), 0, -this.getValue(0)],\r\n            [-this.getValue(1), this.getValue(0), 0]\r\n        ]);\r\n\r\n        return skewSymmetric.mult(tensor);\r\n    }\r\n\r\n    /**\r\n     * only for vectors\r\n     * @returns {number}\r\n     */\r\n    length() {\r\n        if (!Matrix.isVector(this))\r\n            throw TypeError('this is not vector');\r\n\r\n        return Math.sqrt(this.dot(this));\r\n    }\r\n\r\n    /**\r\n     * @returns {Float32Array}\r\n     */\r\n    toFloat32Array() {\r\n        let rows = this.rows;\r\n        let columns = this.columns;\r\n\r\n        let result = new Float32Array(rows * columns);\r\n\r\n        for (let j = 0; j < columns; ++j)\r\n            for (let i = 0; i < rows; ++i)\r\n                result[j * rows + i] = this.getValue(i, j);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param data\r\n     * @returns {Matrix}\r\n     */\r\n    static vector(data) {\r\n        let result = new Matrix(data.length, 1);\r\n        data.forEach((e, i) => result.setValue(i, 0, e));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Matrix} tensor\r\n     * @param {number} [dimension]\r\n     * @returns {boolean}\r\n     */\r\n    static isVector(tensor, dimension) {\r\n        return tensor instanceof Matrix && tensor.columns === 1 && (dimension === undefined || tensor.rows === dimension);\r\n    }\r\n\r\n    /**\r\n     * creates i\r\n     * @param {number} [n=4]\r\n     * @returns {Matrix}\r\n     */\r\n    static identity(n) {\r\n        if (!n)\r\n            n = 4;\r\n\r\n        let result = new Matrix(n, n);\r\n        for (let i = 0; i < n; ++i)\r\n            result.setValue(i, i, 1);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Array<Array<number>>} rows\r\n     * @returns {Matrix}\r\n     */\r\n    static fromRows(rows) {\r\n        let height = rows.length;\r\n        if (height === 0)\r\n            return new Matrix(0, 0);\r\n        let width = rows[0].length;\r\n\r\n        if (rows.some(row => row.length !== width))\r\n            throw new TypeError('all rows should have the same length');\r\n\r\n        let result = new Matrix(width, height);\r\n        rows.forEach((row, i) => row.forEach((v, j) => result.setValue(i, j, v)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} left\r\n     * @param {number} right\r\n     * @param {number} top\r\n     * @param {number} bottom\r\n     * @param {number} zNear\r\n     * @param {number} zFar\r\n     * @returns {Matrix}\r\n     */\r\n    static frustum(left, right, top, bottom, zNear, zFar) {\r\n        let result = new Matrix(4, 4);\r\n\r\n        result.setValue(0, 0, 2 * zNear / (right - left));\r\n        result.setValue(0, 2, (right + left) / (left - right));\r\n        result.setValue(1, 1, 2 * zNear / (top - bottom));\r\n        result.setValue(1, 2, (top + bottom) / (top - bottom));\r\n        result.setValue(2, 2, -(zFar + zNear) / (zFar - zNear));\r\n        result.setValue(2, 3, -2 * zFar * zNear / (zFar - zNear));\r\n        result.setValue(3, 2, -1);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} fov\r\n     * @param {number} aspect\r\n     * @param {number} zNear\r\n     * @param {number} zFar\r\n     * @returns {Matrix}\r\n     */\r\n    static perspective(fov, aspect, zNear, zFar) {\r\n        let yMax = zNear * Math.tan(fov * Math.PI / 360.0);\r\n        let yMin = -yMax;\r\n        let xMin = yMin * aspect;\r\n        let xMax = yMax * aspect;\r\n\r\n        return Matrix.frustum(xMin, xMax, yMax, yMin, zNear, zFar);\r\n    }\r\n\r\n    static translate(vec) {\r\n        let valid = vec instanceof Matrix && vec.columns === 1 && (vec.rows === 3 || vec.rows === 4);\r\n        if (!valid)\r\n            throw new TypeError('invalid vector');\r\n\r\n        let result = Matrix.identity();\r\n\r\n        result.setValue(0, 3, vec.getValue(0, 0));\r\n        result.setValue(1, 3, vec.getValue(1, 0));\r\n        result.setValue(2, 3, vec.getValue(2, 0));\r\n        if (vec.rows === 4)\r\n            result.setValue(3, 3, vec.getValue(3, 0));\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport default Matrix;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./webgl-library/Matrix.js\n// module id = 0\n// module chunks = 2","'use strict';\r\n\r\nimport Shader from './Shader';\r\nimport Program from './Program';\r\nimport Mesh from './Mesh';\r\n\r\n/**\r\n * The most important class of entire library\r\n */\r\nclass Context {\r\n    /**\r\n     * @param {HTMLCanvasElement} canvas Where image should be rendered\r\n     */\r\n    constructor(canvas) {\r\n        this._gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n        if (!this._gl) {\r\n            throw new Error('Unable to initialize WebGL context');\r\n        }\r\n        let gl = this.gl;\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n        gl.clearColor(0, 0, 0, 1);\r\n        gl.clearDepth(1.0);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.depthFunc(gl.LEQUAL);\r\n    }\r\n\r\n    get gl() {\r\n        return this._gl;\r\n    }\r\n\r\n    /**\r\n     * @param {string} srcURI\r\n     * @param {Number} type\r\n     * @returns {Promise<Shader>}\r\n     */\r\n    createShader(srcURI, type) {\r\n        return fetch(srcURI)\r\n            .then(response => response.text())\r\n            .then(source => {\r\n                let gl = this.gl;\r\n                let shader = gl.createShader(type);\r\n                if (!shader) {\r\n                    return Promise.reject(new Error(`invalid type: '${type}'`));\r\n                }\r\n\r\n                gl.shaderSource(shader, source);\r\n                gl.compileShader(shader);\r\n\r\n                let failed = !gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n                if (failed) {\r\n                    let log = gl.getShaderInfoLog(shader);\r\n                    gl.deleteShader(shader);\r\n                    return Promise.reject(new Error(log));\r\n                }\r\n\r\n                return new Shader(this, shader);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @param {Array<Shader>} shaders\r\n     * @returns {Promise<Program>}\r\n     */\r\n    createProgram(shaders) {\r\n        if (!shaders || !(shaders instanceof Array) || shaders.length === 0)\r\n            return Promise.reject(new Error('Invalid argument'));\r\n\r\n        return Promise.all(shaders)\r\n            .then(shaders => {\r\n                if (shaders.some(s => !(s instanceof Shader)))\r\n                    return Promise.reject(new Error('Promise returned invalid value'));\r\n\r\n                if (shaders.some(s => s.context !== this))\r\n                    return Promise.reject(new Error('Shader belongs to other context'));\r\n\r\n                let gl = this.gl;\r\n\r\n                let program = gl.createProgram();\r\n                if (!program) {\r\n                    return Promise.reject(new Error('Shader program cannot be created'));\r\n                }\r\n                shaders.forEach(s => gl.attachShader(program, s.shader));\r\n\r\n                gl.linkProgram(program);\r\n                gl.validateProgram(program);\r\n\r\n                let failed = !gl.getProgramParameter(program, gl.LINK_STATUS);\r\n                if(failed){\r\n                    let log = gl.getProgramInfoLog(program);\r\n                    gl.deleteProgram(program);\r\n                    shaders.forEach(s => s.dispose());\r\n                    return Promise.reject(new Error(log));\r\n                }\r\n\r\n                return new Program(this, shaders, program);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @param {Program} program\r\n     * @returns {Mesh}\r\n     */\r\n    createMesh(program){\r\n        let valid = program instanceof Program && program.context === this;\r\n        if(!valid)\r\n            throw new TypeError('invalid program');\r\n\r\n        return new Mesh(this, program);\r\n    }\r\n}\r\n\r\nexport default Context;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./webgl-library/Context.js\n// module id = 1\n// module chunks = 2","'use strict';\r\nimport Matrix from './Matrix';\r\n\r\nconst PRECISION = 1e-6;\r\n\r\nclass Quaternion {\r\n    /**\r\n     * @param {number} scalar\r\n     * @param {Matrix} vector\r\n     */\r\n    constructor(scalar, vector) {\r\n        let valid = typeof scalar === 'number' && Matrix.isVector(vector, 3);\r\n        if (!valid)\r\n            throw new Error('invalid arguments type');\r\n\r\n        let length = scalar * scalar + vector.dot(vector);\r\n        if (Math.abs(length - 1) > PRECISION)\r\n            throw new Error('quaternion must have unit length');\r\n\r\n        this._w = scalar;\r\n        this._v = vector.clone();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Quaternion} q\r\n     * @returns {Quaternion}\r\n     */\r\n    mult(q) {\r\n        let r1 = this._w;\r\n        let r2 = q._w;\r\n\r\n        let v1 = this._v;\r\n        let v2 = q._v;\r\n\r\n        let scalarPart = r1 * r2 - v1.dot(v2);\r\n        let vectorPart = v2.mult(r1).add(v1.mult(r2)).add(v1.cross(v2));\r\n\r\n        return new Quaternion(scalarPart, vectorPart);\r\n    }\r\n\r\n    /**\r\n     * @returns {Quaternion}\r\n     */\r\n    clone() {\r\n        return new Quaternion(this._w, this._v.clone());\r\n    }\r\n\r\n    /**\r\n     * @returns {Quaternion}\r\n     */\r\n    conjugate() {\r\n        return new Quaternion(this._w, this._v.mult(-1));\r\n    }\r\n\r\n    /**\r\n     * @returns Matrix returns axial vector\r\n     */\r\n    toAxis(){\r\n        let length = this._v.length();\r\n        if(length === 0)\r\n            return Matrix.vector([0, 0, 0]);\r\n\r\n        let angle = 2 * Math.acos(this._w);\r\n\r\n        if(angle > Math.PI)\r\n            angle = angle - 2 * Math.PI;\r\n        if(angle < -Math.PI)\r\n            angle = angle + 2 * Math.PI;\r\n\r\n        return this._v.mult(angle / length);\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix} converts into ordinary 4x4 matrix\r\n     */\r\n    toMatrix() {\r\n        let q0 = this._w;\r\n        let q1 = this._v.getValue(0);\r\n        let q2 = this._v.getValue(1);\r\n        let q3 = this._v.getValue(2);\r\n\r\n        return Matrix.fromRows([\r\n            [1 - 2 * (q2 * q2 + q3 * q3), 2 * (q1 * q2 - q0 * q3), 2 * (q0 * q2 + q1 * q3), 0],\r\n            [2 * (q1 * q2 + q0 * q3), 1 - 2 * (q1 * q1 + q3 * q3), 2 * (q2 * q3 - q0 * q1), 0],\r\n            [2 * (q1 * q3 - q0 * q2), 2 * (q0 * q1 + q2 * q3), 1 - 2 * (q1 * q1 + q2 * q2), 0],\r\n            [0, 0, 0, 1]\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * @param {Matrix} axis\r\n     * @param {Number} angle\r\n     * @returns {Quaternion}\r\n     */\r\n\r\n    static rotateRadians(axis, angle) {\r\n        if (!Matrix.isVector(axis, 3))\r\n            throw new TypeError('Axis should be 3d vector');\r\n\r\n        let length = axis.length();\r\n\r\n        if (Math.abs(length) < PRECISION) {\r\n            axis = Matrix.vector([1, 0, 0]);\r\n            angle = 0;\r\n            length = 1;\r\n        }\r\n        axis = axis.mult(1 / length);\r\n\r\n        angle *= 0.5;\r\n\r\n        let scalarPart = Math.cos(angle);\r\n        let vectorPart = axis.mult(Math.sin(angle));\r\n\r\n        return new Quaternion(scalarPart, vectorPart);\r\n    }\r\n\r\n    /**\r\n     * @param {Matrix} axis\r\n     * @param {Number} angle\r\n     * @returns {Quaternion}\r\n     */\r\n    static rotateDegrees(axis, angle) {\r\n        return Quaternion.rotateRadians(axis, angle / 180 * Math.PI);\r\n    }\r\n}\r\nexport default Quaternion;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./webgl-library/Quaternion.js\n// module id = 2\n// module chunks = 2","'use strict';\r\n\r\nimport Matrix from './Matrix';\r\n\r\nclass Mesh {\r\n\r\n    /**\r\n     * @param {Context} context\r\n     * @param {Program} program\r\n     */\r\n    constructor(context, program) {\r\n        this._context = context;\r\n        this._program = program;\r\n        this._buffers = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @param {Matrix} matrix\r\n     */\r\n    setUniformMatrix(name, matrix) {\r\n        let valid = matrix instanceof Matrix && matrix.rows === matrix.columns && (matrix.rows >= 2 || matrix.rows <= 4);\r\n\r\n        if (!valid)\r\n            throw new TypeError('Invalid matrix argument');\r\n\r\n        let location = this._program.getUniformLocation(name);\r\n        let gl = this._context.gl;\r\n\r\n        this._program.use();\r\n        switch (matrix.rows){\r\n            case 2:\r\n                gl.uniformMatrix2fv(location, false, matrix.toFloat32Array());\r\n                break;\r\n            case 3:\r\n                gl.uniformMatrix3fv(location, false, matrix.toFloat32Array());\r\n                break;\r\n            case 4:\r\n                gl.uniformMatrix4fv(location, false, matrix.toFloat32Array());\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} options.buffer\r\n     * @param {string} options.attribute\r\n     */\r\n    setAttribute(options) {\r\n        if(!options) throw new Error('options expected');\r\n        if(!options.buffer) throw new Error('buffer name expected');\r\n        if(!options.attribute) throw new Error('attribute name expected');\r\n\r\n        let gl = this._context.gl;\r\n        let location = this._program.getAttributeLocation(options.attribute);\r\n        let buffer = this._buffers[options.buffer];\r\n        if(!buffer)\r\n            throw new Error('invalid buffer name');\r\n\r\n        gl.bindBuffer(buffer.target, buffer.handle);\r\n        gl.vertexAttribPointer(location, buffer.dimensions, buffer.dataType, false, 0, 0);\r\n\r\n        this._program.use();\r\n        gl.enableVertexAttribArray(location);\r\n    }\r\n\r\n    /**\r\n     * @param {string} options.bufferName\r\n     * @param {number} options.target\r\n     * @param {object} options.data\r\n     * @param {number} options.usage\r\n     * @param {number} [options.dimensions]\r\n     * @param {number} [options.mode]\r\n     * @param {number} options.dataType\r\n     */\r\n    setBufferData(options){\r\n        if(!options) throw new Error('options expected');\r\n        if(!options.bufferName) throw new Error('bufferName expected');\r\n        if(!options.target) throw new Error('target type expected');\r\n        if(!options.data) throw new Error('data expected');\r\n        if(!options.usage) throw new Error('usage mode of buffer expected');\r\n        if(!options.dataType) throw new Error('dataType expected');\r\n\r\n        let gl = this._context.gl;\r\n        let buffer;\r\n        if(options.bufferName in this._buffers)\r\n            buffer = this._buffers[options.bufferName].handle;\r\n        else\r\n            buffer = gl.createBuffer();\r\n\r\n        gl.bindBuffer(options.target, buffer);\r\n        gl.bufferData(options.target, options.data, options.usage);\r\n\r\n        if(!(options.bufferName in this._buffers)) {\r\n            this._buffers[options.bufferName] = {\r\n                handle: buffer,\r\n                dimensions: options.dimensions,\r\n                dataType: options.dataType,\r\n                length: options.data.length,\r\n                target: options.target,\r\n                mode: options.mode\r\n            };\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {string} attributeName\r\n     * @param {Array<number>} data\r\n     */\r\n    loadAttribute3f(attributeName, data){\r\n        const gl = this._context.gl;\r\n\r\n        this.setBufferData({\r\n            bufferName: attributeName,\r\n            target: gl.ARRAY_BUFFER,\r\n            data: new Float32Array(data),\r\n            usage: gl.STATIC_DRAW,\r\n            dimensions: 3,\r\n            dataType: gl.FLOAT\r\n        });\r\n\r\n        this.setAttribute({\r\n            buffer: attributeName,\r\n            attribute: attributeName\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {string} indicesBuffer\r\n     */\r\n    render(indicesBuffer){\r\n        let gl = this._context.gl;\r\n        let buffer = this._buffers[indicesBuffer];\r\n        if(!buffer)\r\n            throw new Error('invalid buffer name');\r\n\r\n        gl.bindBuffer(buffer.target, buffer.handle);\r\n        gl.drawElements(buffer.mode, buffer.length, buffer.dataType, 0);\r\n    }\r\n\r\n    dispose() {\r\n        Object.getOwnPropertyNames(this._buffers)\r\n            .forEach(name => this._context.gl.deleteBuffer(this._buffers[name].handle));\r\n        this._buffers = {};\r\n    }\r\n}\r\n\r\nexport default Mesh;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./webgl-library/Mesh.js\n// module id = 5\n// module chunks = 2","'use strict';\r\n\r\nclass Program {\r\n    /**\r\n     *\r\n     * @param {Context} context\r\n     * @param {Array<Shader>}shaders\r\n     * @param {WebGLProgram} program\r\n     */\r\n    constructor(context, shaders, program) {\r\n        this._context = context;\r\n        this._shaders = shaders;\r\n        this._program = program;\r\n\r\n        this._attributeLocations = {};\r\n        this._uniformLocations = {};\r\n    }\r\n\r\n    /**\r\n     * Makes this program active\r\n     */\r\n    use() {\r\n        this._context.gl.useProgram(this._program);\r\n    }\r\n\r\n    /**\r\n     * Correctly deletes this program and child shaders\r\n     */\r\n    dispose() {\r\n        let gl = this._context.gl;\r\n\r\n        gl.deleteProgram(this._program);\r\n        this._shaders.forEach(s => s.dispose());\r\n    }\r\n\r\n    /**\r\n     * @returns {Context}\r\n     */\r\n    get context() {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * @param {string} name\r\n     */\r\n    getAttributeLocation(name) {\r\n        if (name in this._attributeLocations)\r\n            return this._attributeLocations[name];\r\n\r\n        let gl = this._context.gl;\r\n        let location = gl.getAttribLocation(this._program, name);\r\n        if (location === -1)\r\n            throw new Error(`Vertex shader does not have attribute ${name}`);\r\n\r\n        this._attributeLocations[name] = location;\r\n\r\n        return location;\r\n    }\r\n\r\n    getUniformLocation(name) {\r\n        if (name in this._uniformLocations)\r\n            return this._uniformLocations[name];\r\n\r\n        let gl = this._context.gl;\r\n        let location = gl.getUniformLocation(this._program, name);\r\n\r\n        if (location === null)\r\n            throw new Error(`Shader program does not have uniform ${name}`);\r\n\r\n        this._uniformLocations[name] = location;\r\n\r\n        return location;\r\n    }\r\n}\r\n\r\nexport default Program;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./webgl-library/Program.js\n// module id = 6\n// module chunks = 2","'use strict';\r\n\r\nclass Shader {\r\n    /**\r\n     * @param {Context} context\r\n     * @param {WebGLShader} shader\r\n     */\r\n    constructor(context, shader) {\r\n        this._context = context;\r\n        this._shader = shader;\r\n    }\r\n\r\n    /**\r\n     * @returns {Context}\r\n     */\r\n    get context(){\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * @returns {WebGLShader}\r\n     */\r\n    get shader(){\r\n        return this._shader;\r\n    }\r\n\r\n    /**\r\n     * Correctly deletes shader from WebGL context\r\n     */\r\n    dispose(){\r\n        let gl = this._context.gl;\r\n        gl.deleteShader(this._shader);\r\n    }\r\n}\r\n\r\nexport default Shader;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./webgl-library/Shader.js\n// module id = 7\n// module chunks = 2"],"sourceRoot":""}