{"version":3,"sources":["webpack:///webpack/bootstrap b4e85ab11ff15433213a","webpack:///./lib/Matrix.js","webpack:///./lib/Context.js","webpack:///./lib/Quaternion.js","webpack:///./lib/Mesh.js","webpack:///./lib/Program.js","webpack:///./lib/Shader.js","webpack:///./demo/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,eAAe;AAC1C,+BAA+B,oBAAoB;AACnD;AACA,mCAAmC,kBAAkB;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,uBAAuB,eAAe;AACtC,2BAA2B,kBAAkB;AAC7C;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC,2BAA2B,UAAU;AACrC;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+D;;;;;;;;;;ACtWA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,KAAK;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gE;;;;;;;;AC/GA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mE;;;;;;;;ACvGA;;AAEA;;AAEA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,YAAY;AACvC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6D;;;;;;;ACnHA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE,KAAK;;AAE1E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oEAAoE,KAAK;;AAEzE;;AAEA;AACA;AACA;;AAEA,gE;;;;;;;AC3EA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+D;;;;;;;;;;;ACnCA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL,CAAC,qB","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b4e85ab11ff15433213a","'use strict';\r\n\r\nclass Matrix {\r\n    /**\r\n     *\r\n     * @param {number} rows\r\n     * @param {number} cols\r\n     */\r\n    constructor(rows, cols) {\r\n        this._rows = rows;\r\n        this._cols = cols;\r\n\r\n        this._data = new Array(rows * cols);\r\n        for (let i = 0; i < this._data.length; ++i)\r\n            this._data[i] = 0;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get rows() {\r\n        return this._rows;\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get columns() {\r\n        return this._cols;\r\n    }\r\n\r\n    /**\r\n     * @param {number} row\r\n     * @param {number} col\r\n     * @param {number} value\r\n     */\r\n    setValue(row, col, value) {\r\n        if (value === undefined) {\r\n            value = col;\r\n            col = 0;\r\n        }\r\n\r\n        if (row < 0 || col < 0 || row >= this.rows || col >= this.columns)\r\n            throw new RangeError(\"invalid index\");\r\n\r\n        this._data[col + row * this.columns] = value;\r\n    }\r\n\r\n    /**\r\n     * @param row\r\n     * @param col\r\n     * @returns {number}\r\n     */\r\n    getValue(row, col) {\r\n        if (col === undefined)\r\n            col = 0;\r\n\r\n        if (row < 0 || col < 0 || row >= this.rows || col >= this.columns)\r\n            throw new RangeError(\"invalid index\");\r\n\r\n        return this._data[col + row * this.columns];\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix}\r\n     */\r\n    clone() {\r\n        let result = new Matrix(this.rows, this.columns);\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(i, j, this.getValue(i, j));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param matrix\r\n     * @returns {Matrix}\r\n     */\r\n    add(matrix) {\r\n        if (matrix.rows != this.rows || matrix.columns != this.columns)\r\n            throw new TypeError(\"invalid argument\");\r\n\r\n        let result = new Matrix(this.rows, this.columns);\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(i, j, this.getValue(i, j) + matrix.getValue(i, j));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param matrix\r\n     * @returns {Matrix}\r\n     */\r\n    sub(matrix) {\r\n        if (matrix.rows != this.rows || matrix.columns != this.columns)\r\n            throw new TypeError(\"invalid argument\");\r\n\r\n        let result = new Matrix(this.rows, this.columns);\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(i, j, this.getValue(i, j) - matrix.getValue(i, j));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param tensor\r\n     * @returns {Matrix}\r\n     */\r\n    mult(tensor) {\r\n        if (typeof tensor === 'number') {\r\n            let result = new Matrix(this.rows, this.columns);\r\n            for (let i = 0; i < this.rows; ++i)\r\n                for (let j = 0; j < this.columns; ++j)\r\n                    result.setValue(i, j, this.getValue(i, j) * tensor);\r\n            return result;\r\n        }\r\n        else if (tensor instanceof Matrix) {\r\n            if (this.columns != tensor.rows)\r\n                throw new RangeError(\"invalid size\");\r\n\r\n            let result = new Matrix(this.rows, tensor.columns);\r\n\r\n            for (let i = 0; i < this.rows; ++i)\r\n                for (let j = 0; j < tensor.columns; ++j) {\r\n                    let sum = 0;\r\n                    for (let k = 0; k < this.columns; ++k)\r\n                        sum = sum + this.getValue(i, k) * tensor.getValue(k, j);\r\n\r\n                    result.setValue(i, j, sum);\r\n                }\r\n\r\n            return result;\r\n        }\r\n        else\r\n            throw new TypeError(\"not implemented yet\");\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix}\r\n     */\r\n    transpose() {\r\n        let result = new Matrix(this.columns, this.rows);\r\n\r\n        for (let i = 0; i < this.rows; ++i)\r\n            for (let j = 0; j < this.columns; ++j)\r\n                result.setValue(j, i, this.getValue(i, j));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix}\r\n     */\r\n    inverse() {\r\n        if (this.rows != this.columns || this.rows < 1)\r\n            throw new TypeError(\"invalid matrix sizes\");\r\n\r\n        let result = Matrix.createIdentityMatrix(this.rows);\r\n        let self = this.clone();\r\n\r\n        for (let i = 0; i < self.rows; ++i) {\r\n            let diagonal = self.getValue(i, i);\r\n            if (diagonal === 0)\r\n                throw new Error(\"determinants equals zero\");\r\n\r\n            for (let j = 0; j < self.columns; ++j) {\r\n                self.setValue(i, j, self.getValue(i, j) / diagonal);\r\n                result.setValue(i, j, result.getValue(i, j) / diagonal);\r\n            }\r\n\r\n            for (let k = 0; k < self.rows; ++k) {\r\n                if (k === i) continue;\r\n                let coefficient = self.getValue(k, i);\r\n                for (let j = 0; j < self.columns; ++j) {\r\n                    self.setValue(k, j, self.getValue(k, j) - self.getValue(i, j) * coefficient);\r\n                    result.setValue(k, j, result.getValue(k, j) - result.getValue(i, j) * coefficient);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * only for vectors\r\n     * @param tensor\r\n     * @returns {number}\r\n     */\r\n    dot(tensor) {\r\n        let valid = Matrix.isVector(this) && Matrix.isVector(tensor) && this.rows === tensor.rows;\r\n        if (!valid)\r\n            throw TypeError('invalid tensor types');\r\n        let sum = 0;\r\n        for (let i = 0; i < this.rows; ++i)\r\n            sum = sum + this.getValue(i, 0) * tensor.getValue(i, 0);\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n     * only for vectors\r\n     * @param {Matrix} tensor\r\n     * @returns {Matrix}\r\n     */\r\n    cross(tensor) {\r\n        let valid = Matrix.isVector(this, 3) && Matrix.isVector(tensor, 3);\r\n\r\n        if (!valid)\r\n            throw TypeError('invalid tensor types');\r\n\r\n        let skewSymmetric = Matrix.fromRows([\r\n            [0, -this.getValue(2), this.getValue(1)],\r\n            [this.getValue(2), 0, -this.getValue(0)],\r\n            [-this.getValue(1), this.getValue(0), 0]\r\n        ]);\r\n\r\n        return skewSymmetric.mult(tensor);\r\n    }\r\n\r\n    /**\r\n     * only for vectors\r\n     * @returns {number}\r\n     */\r\n    length() {\r\n        if(!Matrix.isVector(this))\r\n            throw TypeError('this is not vector');\r\n\r\n        return Math.sqrt(this.dot(this));\r\n    }\r\n\r\n    /**\r\n     * @returns {Float32Array}\r\n     */\r\n    toFloat32Array() {\r\n        let rows = this.rows;\r\n        let columns = this.columns;\r\n\r\n        let result = new Float32Array(rows * columns);\r\n\r\n        for (let j = 0; j < columns; ++j)\r\n            for (let i = 0; i < rows; ++i)\r\n                result[j * rows + i] = this.getValue(i, j);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @param data\r\n     * @returns {Matrix}\r\n     */\r\n    static vector(data) {\r\n        let result = new Matrix(data.length, 1);\r\n        data.forEach((e, i) => result.setValue(i, 0, e));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Matrix} tensor\r\n     * @param {number} [dimension]\r\n     * @returns {boolean}\r\n     */\r\n    static isVector(tensor, dimension){\r\n        return tensor instanceof Matrix && tensor.columns === 1 && (dimension === undefined || tensor.rows === dimension);\r\n    }\r\n\r\n    /**\r\n     * creates i\r\n     * @param {number} [n=4]\r\n     * @returns {Matrix}\r\n     */\r\n    static identity(n) {\r\n        if (!n)\r\n            n = 4;\r\n\r\n        let result = new Matrix(n, n);\r\n        for (let i = 0; i < n; ++i)\r\n            result.setValue(i, i, 1);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Array<Array<number>>} rows\r\n     * @returns {Matrix}\r\n     */\r\n    static fromRows(rows) {\r\n        let height = rows.length;\r\n        if (height === 0)\r\n            return new Matrix(0, 0);\r\n        let width = rows[0].length;\r\n\r\n        if (rows.some(row => row.length !== width))\r\n            throw new TypeError('all rows should have the same length');\r\n\r\n        let result = new Matrix(width, height);\r\n        rows.forEach((row, i) => row.forEach((v, j) => result.setValue(i, j, v)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} left\r\n     * @param {number} right\r\n     * @param {number} top\r\n     * @param {number} bottom\r\n     * @param {number} zNear\r\n     * @param {number} zFar\r\n     * @returns {Matrix}\r\n     */\r\n    static frustum(left, right, top, bottom, zNear, zFar) {\r\n        let result = new Matrix(4, 4);\r\n\r\n        result.setValue(0, 0, 2 * zNear / (right - left));\r\n        result.setValue(0, 2, (right + left) / (left - right));\r\n        result.setValue(1, 1, 2 * zNear / (top - bottom));\r\n        result.setValue(1, 2, (top + bottom) / (top - bottom));\r\n        result.setValue(2, 2, -(zFar + zNear) / (zFar - zNear));\r\n        result.setValue(2, 3, -2 * zFar * zNear / (zFar - zNear));\r\n        result.setValue(3, 2, -1);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} fov\r\n     * @param {number} aspect\r\n     * @param {number} zNear\r\n     * @param {number} zFar\r\n     * @returns {Matrix}\r\n     */\r\n    static perspective(fov, aspect, zNear, zFar) {\r\n        let yMax = zNear * Math.tan(fov * Math.PI / 360.0);\r\n        let yMin = -yMax;\r\n        let xMin = yMin * aspect;\r\n        let xMax = yMax * aspect;\r\n\r\n        return Matrix.frustum(xMin, xMax, yMax, yMin, zNear, zFar);\r\n    }\r\n\r\n    static translate(vec) {\r\n        let valid = vec instanceof Matrix && vec.columns === 1 && (vec.rows === 3 || vec.rows === 4);\r\n        if (!valid)\r\n            throw new TypeError('invalid vector');\r\n\r\n        let result = Matrix.identity();\r\n\r\n        result.setValue(0, 3, vec.getValue(0, 0));\r\n        result.setValue(1, 3, vec.getValue(1, 0));\r\n        result.setValue(2, 3, vec.getValue(2, 0));\r\n        if (vec.rows === 4)\r\n            result.setValue(3, 3, vec.getValue(3, 0));\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport default Matrix;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Matrix.js\n// module id = 0\n// module chunks = 0","'use strict';\r\n\r\nimport Shader from './Shader'\r\nimport Program from './Program'\r\nimport Mesh from './Mesh'\r\n\r\n/**\r\n * The most important class of all library\r\n */\r\nclass Context {\r\n    /**\r\n     * @param {HTMLCanvasElement} canvas Where image should be rendered\r\n     */\r\n    constructor(canvas) {\r\n        this._gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n        if (!this._gl) {\r\n            throw new Error('Unable to initialize WebGL context');\r\n        }\r\n        let gl = this.gl;\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n        gl.clearColor(0, 0, 0, 1);\r\n        gl.clearDepth(1.0);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.depthFunc(gl.LEQUAL);\r\n    }\r\n\r\n    get gl() {\r\n        return this._gl;\r\n    }\r\n\r\n    /**\r\n     * @param {string} srcURI\r\n     * @param {Number} type\r\n     * @returns {Promise<Shader>}\r\n     */\r\n    createShader(srcURI, type) {\r\n        return fetch(srcURI)\r\n            .then(response => response.text())\r\n            .then(source => {\r\n                let gl = this.gl;\r\n                let shader = gl.createShader(type);\r\n                if (!shader) {\r\n                    return Promise.reject(new Error(`invalid type: '${type}'`));\r\n                }\r\n\r\n                gl.shaderSource(shader, source);\r\n                gl.compileShader(shader);\r\n\r\n                let failed = !gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n                if (failed) {\r\n                    let log = gl.getShaderInfoLog(shader);\r\n                    gl.deleteShader(shader);\r\n                    return Promise.reject(new Error(log));\r\n                }\r\n\r\n                return new Shader(this, shader);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @param {Array<Shader>} shaders\r\n     * @returns {Promise<Program>}\r\n     */\r\n    createProgram(shaders) {\r\n        if (!shaders || !(shaders instanceof Array) || shaders.length === 0)\r\n            return Promise.reject(new Error('Invalid argument'));\r\n\r\n        return Promise.all(shaders)\r\n            .then(shaders => {\r\n                if (shaders.some(s => !(s instanceof Shader)))\r\n                    return Promise.reject(new Error('Promise returned invalid value'));\r\n\r\n                if (shaders.some(s => s.context !== this))\r\n                    return Promise.reject(new Error('Shader belongs to other context'));\r\n\r\n                let gl = this.gl;\r\n\r\n                let program = gl.createProgram();\r\n                if (!program) {\r\n                    return Promise.reject(new Error('Shader program cannot be created'));\r\n                }\r\n                shaders.forEach(s => gl.attachShader(program, s.shader));\r\n\r\n                gl.linkProgram(program);\r\n                gl.validateProgram(program);\r\n\r\n                let failed = !gl.getProgramParameter(program, gl.LINK_STATUS);\r\n                if(failed){\r\n                    let log = gl.getProgramInfoLog(program);\r\n                    gl.deleteProgram(program);\r\n                    shaders.forEach(s => s.dispose());\r\n                    return Promise.reject(new Error(log));\r\n                }\r\n\r\n                return new Program(this, shaders, program);\r\n            })\r\n    }\r\n\r\n    /**\r\n     * @param {Program} program\r\n     * @returns {Mesh}\r\n     */\r\n    createMesh(program){\r\n        let valid = program instanceof Program && program.context === this;\r\n        if(!valid)\r\n            throw new TypeError('invalid program');\r\n\r\n        return new Mesh(this, program);\r\n    }\r\n}\r\n\r\nexport default Context;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Context.js\n// module id = 1\n// module chunks = 0","'use strict';\r\nimport Matrix from './Matrix';\r\n\r\nconst PRECISION = 1e-6;\r\n\r\nclass Quaternion {\r\n    /**\r\n     * @param {Matrix} vector - 4d unit (+-1e-6) vector\r\n     */\r\n    constructor(vector) {\r\n        if (!Matrix.isVector(vector, 4))\r\n            throw new TypeError('invalid parameter');\r\n\r\n        let length = vector.length();\r\n\r\n        if (Math.abs(length - 1) > PRECISION)\r\n            throw new TypeError('vector should be unit');\r\n\r\n        this._r = vector.getValue(0);\r\n        this._v = Matrix.vector([vector.getValue(1), vector.getValue(2), vector.getValue(3)]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {Quaternion} q\r\n     * @returns {Quaternion}\r\n     */\r\n    mult(q) {\r\n        let r1 = this._r;\r\n        let r2 = q._r;\r\n\r\n        let v1 = this._v;\r\n        let v2 = q._v;\r\n\r\n        let scalarPart = r1 * r2 - v1.dot(v2);\r\n        let vectorPart = v2.mult(r1).add(v1.mult(r2)).add(v1.cross(v2));\r\n\r\n        return new Quaternion(Matrix.vector([\r\n            scalarPart,\r\n            vectorPart.getValue(0),\r\n            vectorPart.getValue(1),\r\n            vectorPart.getValue(2)\r\n        ]));\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix} 4x4\r\n     */\r\n    toMatrix() {\r\n        let q0 = this._r;\r\n        let q1 = this._v.getValue(0);\r\n        let q2 = this._v.getValue(1);\r\n        let q3 = this._v.getValue(2);\r\n\r\n        return Matrix.fromRows([\r\n            [1 - 2 * (q2 * q2 + q3 * q3), 2 * (q1 * q2 - q0 * q3), 2 * (q0 * q2 + q1 * q3), 0],\r\n            [2 * (q1 * q2 + q0 * q3), 1 - 2 * (q1 * q1 + q3 * q3), 2 * (q2 * q3 - q0 * q1), 0],\r\n            [2 * (q1 * q3 - q0 * q2), 2 * (q0 * q1 + q2 * q3), 1 - 2 * (q1 * q1 + q2 * q2), 0],\r\n            [0, 0, 0, 1]\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * @param {Matrix} axis\r\n     * @param {Number} angle\r\n     * @returns {Quaternion}\r\n     */\r\n\r\n    static rotateRadians(axis, angle) {\r\n        if (!Matrix.isVector(axis, 3))\r\n            throw new TypeError('Axis shoud be 3d vector');\r\n\r\n        let length = axis.length();\r\n\r\n        if (Math.abs(length) < PRECISION) {\r\n            axis = Matrix.vector([1, 0, 0]);\r\n            angle = 0;\r\n            length = 1;\r\n        }\r\n        axis = axis.mult(1 / length);\r\n\r\n        angle *= 0.5;\r\n\r\n        let scalarPart = Math.cos(angle);\r\n        let vectorPart = axis.mult(Math.sin(angle));\r\n\r\n        return new Quaternion(Matrix.vector([\r\n            scalarPart,\r\n            vectorPart.getValue(0),\r\n            vectorPart.getValue(1),\r\n            vectorPart.getValue(2)\r\n        ]));\r\n    }\r\n\r\n    /**\r\n     * @param {Matrix} axis\r\n     * @param {Number} angle\r\n     * @returns {Quaternion}\r\n     */\r\n    static rotateDegrees(axis, angle) {\r\n        return Quaternion.rotateRadians(axis, angle / 180 * Math.PI);\r\n    }\r\n}\r\nexport default Quaternion;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Quaternion.js\n// module id = 2\n// module chunks = 0","'use strict';\r\n\r\nimport Matrix from './Matrix'\r\n\r\nclass Mesh {\r\n\r\n    /**\r\n     * @param {Context} context\r\n     * @param {Program} program\r\n     */\r\n    constructor(context, program) {\r\n        this._context = context;\r\n        this._program = program;\r\n        this._buffers = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} name\r\n     * @param {Matrix} matrix\r\n     */\r\n    setUniformMatrix(name, matrix) {\r\n        let valid = matrix instanceof Matrix && matrix.rows === matrix.columns && (matrix.rows >= 2 || matrix.rows <= 4);\r\n\r\n        if (!valid)\r\n            throw new TypeError('Invalid matrix argument');\r\n\r\n        let location = this._program.getUniformLocation(name);\r\n        let gl = this._context.gl;\r\n\r\n        this._program.use();\r\n        gl[`uniformMatrix${matrix.rows}fv`](location, false, matrix.toFloat32Array());\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} options.buffer\r\n     * @param {string} options.attribute\r\n     */\r\n    setAttribute(options) {\r\n        if(!options) throw new Error('options expected');\r\n        if(!options.buffer) throw new Error('buffer name expected');\r\n        if(!options.attribute) throw new Error('attribute name expected');\r\n\r\n        let gl = this._context.gl;\r\n        let location = this._program.getAttributeLocation(options.attribute);\r\n        let buffer = this._buffers[options.buffer];\r\n        if(!buffer)\r\n            throw new Error('invalid buffer name');\r\n\r\n        gl.bindBuffer(buffer.target, buffer.handle);\r\n        gl.vertexAttribPointer(location, buffer.dimensions, buffer.dataType, false, 0, 0);\r\n\r\n        this._program.use();\r\n        gl.enableVertexAttribArray(location);\r\n    }\r\n\r\n    /**\r\n     * @param {string} options.bufferName\r\n     * @param {number} options.target\r\n     * @param {object} options.data\r\n     * @param {number} options.usage\r\n     * @param {number} [options.dimensions]\r\n     * @param {number} [options.mode]\r\n     * @param {number} options.dataType\r\n     */\r\n    setBufferData(options){\r\n        if(!options) throw new Error('options expected');\r\n        if(!options.bufferName) throw new Error('bufferName expected');\r\n        if(!options.target) throw new Error('target type expected');\r\n        if(!options.data) throw new Error('data expected');\r\n        if(!options.usage) throw new Error('usage mode of buffer expected');\r\n        if(!options.dataType) throw new Error('dataType expected');\r\n\r\n        let gl = this._context.gl;\r\n        let buffer;\r\n        if(options.bufferName in this._buffers)\r\n            buffer = this._buffers[options.bufferName].handle;\r\n        else\r\n            buffer = gl.createBuffer();\r\n\r\n        gl.bindBuffer(options.target, buffer);\r\n        gl.bufferData(options.target, options.data, options.usage);\r\n\r\n        if(!(options.bufferName in this._buffers)) {\r\n            this._buffers[options.bufferName] = {\r\n                handle: buffer,\r\n                dimensions: options.dimensions,\r\n                dataType: options.dataType,\r\n                length: options.data.length,\r\n                target: options.target,\r\n                mode: options.mode\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {string} indicesBuffer\r\n     */\r\n    render(indicesBuffer){\r\n        let gl = this._context.gl;\r\n        let buffer = this._buffers[indicesBuffer];\r\n        if(!buffer)\r\n            throw new Error('invalid buffer name');\r\n\r\n        gl.drawElements(buffer.mode, buffer.length, buffer.dataType, 0);\r\n    }\r\n\r\n    dispose() {\r\n        Object.getOwnPropertyNames(this._buffers)\r\n            .forEach(name => this._context.gl.deleteBuffer(this._buffers[name].handle));\r\n        this._buffers = {};\r\n    }\r\n}\r\n\r\nexport default Mesh;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Mesh.js\n// module id = 3\n// module chunks = 0","'use strict';\r\n\r\nclass Program {\r\n    /**\r\n     *\r\n     * @param {Context} context\r\n     * @param {Array<Shader>}shaders\r\n     * @param {WebGLProgram} program\r\n     */\r\n    constructor(context, shaders, program) {\r\n        this._context = context;\r\n        this._shaders = shaders;\r\n        this._program = program;\r\n\r\n        this._attributeLocations = {};\r\n        this._uniformLocations = {};\r\n    }\r\n\r\n    /**\r\n     * Makes this program active\r\n     */\r\n    use() {\r\n        this._context.gl.useProgram(this._program);\r\n    }\r\n\r\n    /**\r\n     * Correctly deletes this program and child shaders\r\n     */\r\n    dispose() {\r\n        let gl = this._context.gl;\r\n\r\n        gl.deleteProgram(this._program);\r\n        this._shaders.forEach(s => s.dispose());\r\n    }\r\n\r\n    /**\r\n     * @returns {Context}\r\n     */\r\n    get context() {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * @param {string} name\r\n     */\r\n    getAttributeLocation(name) {\r\n        if (name in this._attributeLocations)\r\n            return this._attributeLocations[name];\r\n\r\n        let gl = this._context.gl;\r\n        let location = gl.getAttribLocation(this._program, name);\r\n        if (location === -1)\r\n            throw new Error(`Vertex shader does not have attribute ${name}`);\r\n\r\n        this._attributeLocations[name] = location;\r\n\r\n        return location;\r\n    }\r\n\r\n    getUniformLocation(name) {\r\n        if (name in this._uniformLocations)\r\n            return this._uniformLocations[name];\r\n\r\n        let gl = this._context.gl;\r\n        let location = gl.getUniformLocation(this._program, name);\r\n\r\n        if (location === null)\r\n            throw new Error(`Shader program does not have uniform ${name}`);\r\n\r\n        this._uniformLocations[name] = location;\r\n\r\n        return location;\r\n    }\r\n}\r\n\r\nexport default Program;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Program.js\n// module id = 4\n// module chunks = 0","'use strict';\r\n\r\nclass Shader {\r\n    /**\r\n     * @param {Context} context\r\n     * @param {WebGLShader} shader\r\n     */\r\n    constructor(context, shader) {\r\n        this._context = context;\r\n        this._shader = shader;\r\n    }\r\n\r\n    /**\r\n     * @returns {Context}\r\n     */\r\n    get context(){\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * @returns {WebGLShader}\r\n     */\r\n    get shader(){\r\n        return this._shader;\r\n    }\r\n\r\n    /**\r\n     * Correctly deletes shader from WebGL context\r\n     */\r\n    dispose(){\r\n        let gl = this._context.gl;\r\n        gl.deleteShader(this._shader);\r\n    }\r\n}\r\n\r\nexport default Shader;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Shader.js\n// module id = 5\n// module chunks = 0","'use strict';\r\n\r\nimport Context from '../lib/Context'\r\nimport Matrix from '../lib/Matrix'\r\nimport Quaternion from '../lib/Quaternion';\r\n\r\nlet canvas = document.getElementById('glcanvas');\r\n\r\nlet ctx = new Context(canvas);\r\n\r\nlet vertexShaderPromise = ctx.createShader('./shaders/vertex.glsl', ctx.gl.VERTEX_SHADER);\r\nlet fragmentShaderPromise = ctx.createShader('./shaders/fragment.glsl', ctx.gl.FRAGMENT_SHADER);\r\nlet programPromise = ctx.createProgram([vertexShaderPromise, fragmentShaderPromise]);\r\n\r\nlet vertexData = [\r\n    -1, -1, -1,\r\n    -1, -1, 1,\r\n    -1, 1, -1,\r\n    -1, 1, 1,\r\n\r\n    1, -1, -1,\r\n    1, -1, 1,\r\n    1, 1, -1,\r\n    1, 1, 1,\r\n\r\n\r\n    //axis\r\n    0, 0, 0,\r\n    2, 0, 0,\r\n\r\n    0, 0, 0,\r\n    0, 2, 0\r\n];\r\n\r\nlet colorData = [\r\n    0, 0, 0,\r\n    0, 0, 1,\r\n    0, 1, 0,\r\n    0, 1, 1,\r\n\r\n    1, 0, 0,\r\n    1, 0, 1,\r\n    1, 1, 0,\r\n    1, 1, 1,\r\n\r\n    1, 1, 1,\r\n    1, 1, 1,\r\n\r\n    1, 1, 1,\r\n    1, 1, 1\r\n];\r\n\r\nlet indices = [\r\n    0, 1, 0, 2, 0, 4,\r\n    1, 3, 1, 5,\r\n    2, 3, 2, 6,\r\n    4, 5, 4, 6,\r\n    7, 6, 7, 5, 7, 3,\r\n\r\n    //axis\r\n    8,9,\r\n    10, 11\r\n];\r\n\r\nconst perspective = Matrix.perspective(60, canvas.width / canvas.height, 0.1, 100.0);\r\n\r\nprogramPromise.then(program => {\r\n    let gl = ctx.gl;\r\n\r\n    let translate = Matrix.translate(Matrix.vector([0, 0, -5]));\r\n\r\n    let mesh = ctx.createMesh(program);\r\n    mesh.setUniformMatrix('projection', perspective);\r\n\r\n    mesh.setBufferData({\r\n        bufferName: 'vertices',\r\n        target: gl.ARRAY_BUFFER,\r\n        data: new Float32Array(vertexData),\r\n        usage: gl.STATIC_DRAW,\r\n        dimensions: 3,\r\n        dataType: gl.FLOAT\r\n    });\r\n\r\n    mesh.setBufferData({\r\n        bufferName: 'colors',\r\n        target: gl.ARRAY_BUFFER,\r\n        data: new Float32Array(colorData),\r\n        dimensions: 3,\r\n        dataType: gl.FLOAT,\r\n        usage: gl.STATIC_DRAW\r\n    });\r\n\r\n    mesh.setBufferData({\r\n        bufferName: 'indices',\r\n        target: gl.ELEMENT_ARRAY_BUFFER,\r\n        data: new Uint16Array(indices),\r\n        usage: gl.STATIC_DRAW,\r\n        dataType: gl.UNSIGNED_SHORT,\r\n        mode: gl.LINES\r\n    });\r\n\r\n    mesh.setAttribute({\r\n        buffer: 'vertices',\r\n        attribute: 'vPosition'\r\n    });\r\n\r\n    mesh.setAttribute({\r\n        buffer: 'colors',\r\n        attribute: 'vColor'\r\n    });\r\n\r\n    let angle = 0;\r\n    setInterval(function () {\r\n        angle+=0.1;\r\n        let rotation = Quaternion.rotateDegrees(Matrix.vector([0, 1, 0]), angle)\r\n            .mult(Quaternion.rotateDegrees(Matrix.vector([1, 0, 0]), angle * 0.1));\r\n        mesh.setUniformMatrix('modelView', translate.mult(rotation.toMatrix()));\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        mesh.render('indices');\r\n    }, 0);\r\n\r\n\r\n}).catch(console.log);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demo/index.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}